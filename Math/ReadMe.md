### Math

- [翻转一个整数](/Math/reverse_int.md)
  > 翻转一个整数  
  > ex：x = 123， return  321  
  > ex：x = -918，return -819  
    [7. Reverse Integer of LeetCode](https://leetcode.com/problems/reverse-integer/description/)

<!-- - [计算x的二进制表示中1和0的个数](/Math/bit_count.cpp) -->

- [求两个整数的最小公倍数与最大公约数](/Math/lcm_gcd.md)

- [判断一个数是否为质数](/Math/prime.md)

- [求解斐波那契数列](/Math/fib.md)

- [判断一个整数是否为回文数](/Math/is_palindrome.md)

- [自分割数](/Math/self_divide_number.md)
 	> 自分割数是一个可被其包含的每个数字整除的数字
      例如，128是自分割数，因为128％1 == 0,128％2 == 0，128％8 == 0
      此外，不允许自分割数包含数字零
      给定下限和上限数字，输出包含每个可能的自分割数列表，如果可能，包括边界  
      [728. Self Dividing Numbers of LeetCode](https://leetcode.com/problems/self-dividing-numbers/description/)


- [完美数字](/Math/perfect_number.md)
	> 我们定义Perfect Number是一个正整数，它等于除了它自己之外的所有正除数的总和
      现在，给定一个整数n，编写一个函数，当它是一个完美数字时返回true，否则返回false  
      [507. Perfect Number of LeetCode](https://leetcode.com/problems/perfect-number/description/)

- [BinaryGap](/Math/binary_gap.md)
	> 给定正整数N，找到并返回N的二进制表示中两个连续1之间的最长距离
	  如果没有连续两个1，则返回0  
    [868. Binary Gap of LeetCode](https://leetcode.com/problems/binary-gap/description/)

- [二进制转十进制](/Math/binary2decimal.md)
  > 输入一个仅含0或1数字的整数，将其表示的二进制转化为十进制